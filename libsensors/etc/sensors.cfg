# Conditions:
#
# 1. If sensors are defined, local version runs forever
#    Use --daemon to "sysinspect" to go background in local mode.
#
# 2. It is up to luser define what to do on the events. Sensors only
#    emit the data in JSON to the event handler and nothing else.
#
# 3. Sensors are not a part of any model. It is the listening configuration
#    of a Sysinspect agent (SysMinion or Sysinspect local mode). Their purpose
#    is merely scream if stuff happens. What to do, what model to call (or not)
#    is all up to luser.
#
# 4. Events must be removed from the model itself, because they are always the same
#    anyways and must be part of sensors now.
#

# SYNOPSIS
# sensors:
#   interval:
#     max: 10
#     min: 3
#     unit: seconds|minutes|hours
#
#   <id>:
#     profile:
#       - <profile1>
#       - <profile2>
#     description: <description of the sensor>
#     listener: <listener type>
#     interval: <interval in global units, optional, overrides global one>
#     opts:
#       - <option1>
#       - <option2>
#     args:
#       key: <value>
#
#     event: <event ID to emit on trigger, optional>

sensors:
  # If interval is not specified in the sensor explicitly,
  # A random one within this range will be selected
  interval:
    min: 400
    max: 5000
    unit: milliseconds

  # A random ID
  tmp-watch:
    # Default if not defined at all
    profile:
      - default

    description: Watches /tmp for changes
    listener: fsnotify
    opts:
      - created
      - changed
      - deleted
    args:
      # interval: 5
      # unit: second

      # Listener-specific arg
      path: /tmp

    # Emits a specific event Id that will be captured by the event handler
    event: foo/bar/baz/dang/0

  pid-watch:
    profile:
      - system
      - default
    description: If a particular process appears
    listener: process
    opts:
      - appeared
    args:
      interval: 5
      unit: second

      # Listener-specific arg
      process: vivaldi-bin

    # If event is not explicitly overridden, then default event ID is used
    # in the following format:
    #
    #     event: listener/id/process:[opts]/0
    #
    # In this particular case it will be the following:
    #
    #     event: process/pid-watch/vivaldi-bin:appeared/0
    #
    # To capture that â€” one must be setting up corresponding event handler
    # what to do on that event.

  io:
    description: Measure peak of disk[s] IO
    listener: loadaverage
    opts:
      - disk-io

      # Possible options
      # - free-mem
      # - free-swap
      # - cpu-load
    args:
      # A random interval. See above.

      # Listener-specific arg
      threshold: ">10"

  logged-in-users:
    description: Capture if anyone logged into the system via SSH
    listener: users
    opts:
      # React if any of these appears
      - any
    args:
      # By UID
      uid:
        - 0
        - 10650

      # By user name
      uname:
        - john

  syslog-watch:
    description: Watching a syslod for a specific pattern
    listener: syslog
    opts:
      - any
    args:
      pattern:
        - "snap-store"
        - "E: Failed to fetch https://mirror.company.com"

  diskfree:
    description: See if we have enough disk space
    listener: disk
    opts:
      - free
    args:
      threshold: ">5GB"

# Events are almost identical to events in models, but they are emitted by sensors and not by model actions.
# The difference is the error code doesn't returned, but rather the result from a sensor. For example,
# fsnotify will return the actual file or path configured. This way you can setup one sensor but capture
# different events from it and route them differently.
events:
  $/$/$/$:
      handlers:
        - console-logger
        - outcome-logger

      console-logger:
        concise: false
        prefix: Single Call

      outcome-logger:
        prefix: Single Call
