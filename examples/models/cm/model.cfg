name: Configuration management example
version: "0.1"
description: |
  Configuration management example model

maintainer: John Smith <js@javascriptsucks.com>
checkbook:
relations:
entities:
  file-ops:
    claims:
      $:
        - netconfig:
            name: /tmp/networks.bkp
        - groups:
            src: file:///etc/group
            dst: /tmp/group.bkp

actions:
  download-netconfig:
    descr: Download network cfg to /tmp
    module: fs.file
    bind:
      - file-ops

    state:
      $:
        opts:
          - create
        args:
          name: "claim(netconfig.name)"
          pull: "/networks"

  info-netconfig:
    descr: Display information about network cfg
    module: fs.file

    # Process only if "download-netconfig" was successful
    if-true:
      - download-netconfig
    bind:
      - file-ops
    state:
      $:
        opts:
          - info
        args:
          name: "claim(netconfig.name)"

  delete-netconfig:
    descr: Delete network cfg file
    module: fs.file

    # Process only if "download-netconfig" was successful
    if-true:
      - download-netconfig

    bind:
      - file-ops
    state:
      $:
        opts:
          - delete
        args:
          name: "claim(netconfig.name)"

  copy-groups:
    descr: Copy /etc/group to /tmp
    module: fs.file
    bind:
      - file-ops
    state:
      $:
        opts:
          - create
        args:
          pull: "claim(groups.src)"
          name: "claim(groups.dst)"

  info-groups:
    descr: Display informatino about groups file
    module: fs.file
    bind:
      - file-ops
    state:
      $:
        opts:
          - info
        args:
          name: "claim(groups.dst)"

  delete-groups:
    descr: Delete network cfg file
    module: fs.file
    if-true:
      - info-groups
    bind:
      - file-ops
    state:
      $:
        opts:
          - delete
        args:
          name: "claim(groups.dst)"

constraints:
  download-netconfig:
    descr: Verify if the netconfig was actually downloaded
    entities:
      - file-ops
    all:
      $:
        - fact: changed
          equals: true

  delete-netconfig:
    descr: Networks config should be removed
    entities:
      - file-ops

    all:
      $:
        - fact: changed
          equals: true

  info-groups:
    descr: Check if groups file is there
    entities:
      - file-ops
    all:
      $:
        - fact: changed
          equals: true

events:
  $/$/$/$:
    handler:
      - console-logger
      - outcome-logger

    console-logger:
      concise: false
      prefix: CfgMgmt

    outcome-logger:
      prefix: CfgMgmt

telemetry:
  # Model is basically the same like a minion, just "across all minions".
  # The main difference here data aggregator, which is here to summarise
  # the given data into a meaningful telemetry records.
  model:
    # model selector (traits or globe)
    # Same as for a minion
    - select:
        - "*"

      # The data selector will be a JSONPath expression.
      data:
        my-key: operation-label.result.in.data
        my-other-key: other-label.some.other.data

      # Operations per key, per value. Each operation is a function that
      # will be applied to the value. The result of the operation
      # will be used as a value for the key.
      # Returns a list of results.
      #
      # Valid functions are:
      #   - round
      #   - to-int
      #   - to-float
      #   - to-bool
      #   - to-str
      #   - less-than
      #   - greater-than
      #   - equals
      map:
        my-key: less-than 10
        my-other-key: greater-than 42

      # The reduce function will be applied to the list of results, returned by map.
      # Valid functions are:
      #   - sum
      #   - average
      #   - min
      #   - max
      #   - count
      reduce:
        my-key: sum
        my-other-key: average

      export:
        attr-name: message
        attr-type: string
        attr-format: "This is {my-key} and {my-other-key} data. Static: {foo} and {bar}"
        data-type:
          my-key: string
          my-other-key: int
        telemetry-type: log # or metric, in a future
        static:
          foo: "This is added statically"
          bar: 1234

  minion:
    # minions selector (traits or globe)
    - select:
        - "system.os:Ubuntu"
        - "system.cpu:x86_64"
      data:
        # Depending on the type of the attribute,
        # the data selector will be different. In JSON
        # case, the selector will be a JSONPath expression.
        # Cycles/operations selector.
        # Can select only within the minion scope
        #
        # The idea here is to define a key (anything)
        # that will be filled with the value of the defined path or null.
        # Then these keys can be optionally used in the export section in attr-format
        # to format the data into a static string, for example.
        my-key: operation-label.result.in.data
        my-other-key: other-label.some.other.data

      # How is the future record type will look like as a telemetry entry
      export:
        # Which OTLP attribute to use for the data export
        attr-name: message

        # Serialise into another type. Default is always "json"
        attr-type: string

        # Optionally format into a static data.
        attr-format: "This is {my-key} and {my-other-key} data. Static: {foo} and {bar}"

        # Optionally, explicitly enforce the type of the data per a key.
        # Not all keys needs to be converted/casted.
        data-type:
          my-key: string
          my-other-key: int

        # Telemetry type
        telemetry-type: log # or metric, in a future

        # Optionally, you can define a static data that will be added to the telemetry record
        # Usually used for markers, namespaces, tags etc.
        static:
          foo: "This is added statically"
          bar: 1234

    - select:
        - "web*"
      data:
        foo: other-label.everything
      telemetry-type: log
      export:
        attr-name: message
