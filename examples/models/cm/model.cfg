name: Configuration management example
version: "0.1"
description: |
  Configuration management example model

maintainer: John Smith <js@javascriptsucks.com>
checkbook:
relations:
entities:
  file-ops:
    claims:
      $:
        - netconfig:
            name: /tmp/networks.bkp
        - groups:
            src: file:///etc/group
            dst: /tmp/group.bkp

actions:
  download-netconfig:
    descr: Download network cfg to /tmp
    module: fs.file
    bind:
      - file-ops

    state:
      $:
        opts:
          - create
        args:
          name: "claim(netconfig.name)"
          pull: "/networks"

  info-netconfig:
    descr: Display information about network cfg
    module: fs.file

    # Process only if "download-netconfig" was successful
    if-true:
      - download-netconfig
    bind:
      - file-ops
    state:
      $:
        opts:
          - info
        args:
          name: "claim(netconfig.name)"

  delete-netconfig:
    descr: Delete network cfg file
    module: fs.file

    # Process only if "download-netconfig" was successful
    if-true:
      - download-netconfig

    bind:
      - file-ops
    state:
      $:
        opts:
          - delete
        args:
          name: "claim(netconfig.name)"

  copy-groups:
    descr: Copy /etc/group to /tmp
    module: fs.file
    bind:
      - file-ops
    state:
      $:
        opts:
          - create
        args:
          pull: "claim(groups.src)"
          name: "claim(groups.dst)"

  info-groups:
    descr: Display informatino about groups file
    module: fs.file
    bind:
      - file-ops
    state:
      $:
        opts:
          - info
        args:
          name: "claim(groups.dst)"

  delete-groups:
    descr: Delete network cfg file
    module: fs.file
    if-true:
      - info-groups
    bind:
      - file-ops
    state:
      $:
        opts:
          - delete
        args:
          name: "claim(groups.dst)"

constraints:
  download-netconfig:
    descr: Verify if the netconfig was actually downloaded
    entities:
      - file-ops
    all:
      $:
        - fact: changed
          equals: true

  delete-netconfig:
    descr: Networks config should be removed
    entities:
      - file-ops

    all:
      $:
        - fact: changed
          equals: true

  info-groups:
    descr: Check if groups file is there
    entities:
      - file-ops
    all:
      $:
        - fact: changed
          equals: true

events:
  $/$/$/$:
    handler:
      - console-logger
      - outcome-logger

    console-logger:
      concise: false
      prefix: CfgMgmt

    outcome-logger:
      prefix: CfgMgmt

telemetry:
  # TBD
  model: foo

  minion:
    # minions selector (traits or globe)
    - select:
        - "system.os:Ubuntu"
        - "system.cpu:x86_64"
      data:
        # Depending on the type of the attribute,
        # the data selector will be different. In JSON
        # case, the selector will be a JSONPath expression.
        # Cycles/operations selector.
        # Can select only within the minion scope
        #
        # The idea here is to define a key (anything)
        # that will be filled with the value of the defined path or null.
        # Then these keys can be optionally used in the export section in attr-format
        # to format the data into a static string, for example.
        my-key: operation-label.result.in.data
        my-other-key: other-label.some.other.data

      # How is the future record type will look like as a telemetry entry
      export:
        # Which OTLP attribute to use for the data export
        attr-name: message

        # Serialise into another type. Default is always "json"
        attr-type: string

        # Optionally format into a static data.
        attr-format: "This is {my-key} and {my-other-key} data. Static: {foo} and {bar}"

        # Optionally, explicitly enforce the type of the data per a key.
        # Not all keys needs to be converted/casted.
        data-type:
          my-key: string
          my-other-key: int

        # Telemetry type
        telemetry-type: log # or metric, in a future

        # Optionally, you can define a static data that will be added to the telemetry record
        # Usually used for markers, namespaces, tags etc.
        static:
          foo: "This is added statically"
          bar: 1234

    - select:
        - "web*"
      data:
        foo: other-label.everything
      type: log
      export:
        attr-name: message
