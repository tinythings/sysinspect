telemetry:
  cycle:
    - select:
        - "*"
      data:
        file.size: "$.data.size"

      export:
        attr-name: message

      # Operations per key, per value. Each operation is a function that
      # will be applied to the value. The result of the operation
      # will be used as a value for the key.
      # Returns a list of results.
      #
      # Valid functions are:
      #   - round
      #   - as-int
      #   - as-float
      #   - as-bool
      #   - as-str
      map:
        file.size: as-float

      # The reduce function will be applied to the list of results, returned by map.
      # Valid functions are:
      #   - sum
      #   - average
      #   - min
      #   - max
      #
      # Future:
      #   - more
      #   - less
      #   - equals
      reduce:
        file.size: avg

      # Map/reduce produces a new data. It works the way that first
      # the map function is applied to the data, and then the reduce function is applied to the results,
      # producing a new data. This will be used as a material for the new telemetry records.
      # Functions like more/less/equals will threshold the data accordingly.
      #
      # Use of separate cycles
      use-map: true
      use-reduce: true

  # Model is basically the same like a minion, just "across all actions on a minion".
  # The main difference here data aggregator, which is here to summarise
  # the given data into a meaningful telemetry records.
  minion:
    # model selector (traits or globe)
    # Same as for a minion
    - select:
        - "*"

      # The data selector will be a JSONPath expression.
      data:
        file.name: "$.data.path"
        file.size: "$.data.size"
        file.changed: "$.data.created"

      # Operations per key, per value. Each operation is a function that
      # will be applied to the value. The result of the operation
      # will be used as a value for the key.
      # Returns a list of results.
      #
      # Valid functions are:
      #   - round
      #   - as-int
      #   - as-float
      #   - as-bool
      #   - as-str
      map:
        file.size: as-str

      export:
        attr-name: message
        attr-type: string
        attr-format: "{tag}: This is {file.name} of {file.size} size at {file.changed}"
        telemetry-type: log # or metric, in a future
        static-destination: body
        static:
          tag: "model.map"

  action:
    # minions selector (traits or globe)
    - select:
        - "system.os.name:Ubuntu"
        - "hardware.cpu.total:2"
        - "hardware.memory:>3.5GiB"

      data:
        changed: "$.data.changed"

      export:
        attr-name: message
        event-type: action

        # Static data destination. Either as attributes or included in the body.
        # However, if is set as "body" to be included in the message and the
        # export is string format, then the data might be lost if not interpolated.
        #
        # Values are:
        #   - attributes
        #   - body
        #
        # Default: attributes
        # static-destination: body
        static:
          topic: "file"

    - select:
        - "system.os.name:Ubuntu"
        - "hardware.cpu.total:2"
        - "hardware.memory:>3.5GiB"

      data:
        # Depending on the type of the attribute,
        # the data selector will be different. In JSON
        # case, the selector will be a JSONPath expression.
        # Cycles/operations selector.
        # Can select only within the minion scope
        #
        # The idea here is to define a key (anything)
        # that will be filled with the value of the defined path or null.
        # Then these keys can be optionally used in the export section in attr-format
        # to format the data into a static string, for example.
        #
        file.name: "$.data.path"
        file.size: "$.data.size"

      # How is the future record type will look like as a telemetry entry
      export:
        # Which OTLP attribute to use for the data export
        attr-name: message

        # Serialise into another type. Default is always "json"
        attr-type: string

        # Optionally format into a static data.
        attr-format: "This is {file.name} of size {file.size} bytes. {foo}: {bar}."

        # Optionally, explicitly enforce the type of the data per a key.
        # Not all keys needs to be converted/casted.
        data-type:
          file.size: string # just because :-)

        # Telemetry type
        telemetry-type: log # or metric, in a future

        # Event type defines when to fire this OTEL record
        # The following types are valid:
        # - "action": will fire for each minion on each action
        # - "cycle": will fire for each minion only at the end of the cycle
        #
        # Default value: cycle
        event-type: action # or cycle

        # In order to interpolate the static data into the message body via attr-format,
        # the static-destination should be set to "body".
        static-destination: body

        # Optionally, you can define a static data that will be added to the telemetry record
        # Usually used for markers, namespaces, tags etc.
        # This data will be added to the telemetry record as attributes.
        static:
          foo: "This is added statically"
          bar: 1234

    - select:
        - "system.hostname.fqdn:*db"
      data:
        foo: other-label.everything
      telemetry-type: log
      export:
        attr-name: message
